#include "BlockValidator.h"
#include "../Processors/BlockHeaderProcessor.h"

#include <Crypto/Crypto.h>
#include <Core/Validation/TransactionBodyValidator.h>
#include <Core/Validation/KernelSumValidator.h>
#include <Common/Util/FunctionalUtil.h>
#include <Consensus/Common.h>
#include <PMMR/TxHashSet.h>
#include <algorithm>

BlockValidator::BlockValidator(std::shared_ptr<const IBlockDB> pBlockDB, ITxHashSetConstPtr pTxHashSet)
	: m_pBlockDB(pBlockDB), m_pTxHashSet(pTxHashSet)
{

}

// Validates a block is self-consistent and validates the state (eg. MMRs).
std::unique_ptr<BlockSums> BlockValidator::ValidateBlock(const FullBlock& block) const
{
	if (!IsBlockSelfConsistent(block))
	{
		return std::unique_ptr<BlockSums>(nullptr);
	}

	// Verify coinbase maturity
	const uint64_t maximumBlockHeight = Consensus::GetMaxCoinbaseHeight(block.GetHeight());
	for (const TransactionInput& input : block.GetTransactionBody().GetInputs())
	{
		if (input.IsCoinbase())
		{
			const std::unique_ptr<OutputLocation> pOutputLocation = m_pBlockDB->GetOutputPosition(input.GetCommitment());
			if (pOutputLocation == nullptr || pOutputLocation->GetBlockHeight() > maximumBlockHeight)
			{
				LOG_INFO_F("Coinbase not mature for block %s", block);
				return std::unique_ptr<BlockSums>(nullptr);
			}
		}
	}

	if (!m_pTxHashSet->ValidateRoots(block.GetBlockHeader()))
	{
		return std::unique_ptr<BlockSums>(nullptr);
	}

	const Hash previousHash = block.GetBlockHeader().GetPreviousBlockHash();
	std::unique_ptr<BlockSums> pPreviousBlockSums = m_pBlockDB->GetBlockSums(previousHash);
	if (pPreviousBlockSums == nullptr)
	{
		LOG_WARNING_F("Failed to retrieve block sums for block %s", previousHash);
		return std::unique_ptr<BlockSums>(nullptr);
	}

	return KernelSumValidator::ValidateKernelSums(
		block.GetTransactionBody(),
		0 - Consensus::REWARD,
		block.GetBlockHeader().GetTotalKernelOffset(),
		std::make_optional<BlockSums>(*pPreviousBlockSums)
	);
}

// Validates all the elements in a block that can be checked without additional data. 
// Includes commitment sums and kernels, reward, etc.
bool BlockValidator::IsBlockSelfConsistent(const FullBlock& block) const
{
	if (block.WasValidated())
	{
		LOG_TRACE_F("Block (%s) already validated", block);
		return true;
	}

	if (!TransactionBodyValidator().ValidateTransactionBody(block.GetTransactionBody(), true))
	{
		LOG_ERROR_F("Failed to validate transaction body for %s", block);
		return false;
	}

	if (!VerifyKernelLockHeights(block))
	{
		LOG_ERROR_F("Failed to validate kernel lock heights for %s", block);
		return false;
	}

	if (!VerifyCoinbase(block))
	{
		LOG_ERROR_F("Failed to validate coinbase for %s", block);
		return false;
	}

	block.MarkAsValidated();
	return true;
}

// check we have no kernels with lock_heights greater than current height
// no tx can be included in a block earlier than its lock_height
bool BlockValidator::VerifyKernelLockHeights(const FullBlock& block) const
{
	const uint64_t blockHeight = block.GetBlockHeader().GetHeight();
	const std::vector<TransactionKernel>& kernels = block.GetTransactionBody().GetKernels();
	return !std::any_of(
		kernels.cbegin(),
		kernels.cend(),
		[blockHeight](const TransactionKernel& kernel) { return kernel.GetLockHeight() > blockHeight; }
	);
}

// Validate the coinbase outputs generated by miners.
// Check the sum of coinbase-marked outputs match the sum of coinbase-marked kernels accounting for fees.
bool BlockValidator::VerifyCoinbase(const FullBlock& block) const
{
	// Get Coinbase Output Commitments
	const std::vector<TransactionOutput>& blockOutputs = block.GetTransactionBody().GetOutputs();
	std::vector<Commitment> coinbaseCommitments;
	FunctionalUtil::transform_if(
		blockOutputs.cbegin(),
		blockOutputs.cend(),
		std::back_inserter(coinbaseCommitments),
		[](const TransactionOutput& output) { return output.IsCoinbase(); },
		[](const TransactionOutput& output) { return output.GetCommitment(); }
	);

	// Get Coinbase Kernel Commitments
	const std::vector<TransactionKernel>& blockKernels = block.GetTransactionBody().GetKernels();
	std::vector<Commitment> coinbaseKernelExcesses;
	FunctionalUtil::transform_if(
		blockKernels.cbegin(),
		blockKernels.cend(),
		std::back_inserter(coinbaseKernelExcesses),
		[](const TransactionKernel& kernel) { return kernel.IsCoinbase(); },
		[](const TransactionKernel& kernel) { return kernel.GetExcessCommitment(); }
	);

	// Calculate Block Reward
	const uint64_t reward = std::accumulate(
		blockKernels.cbegin(),
		blockKernels.cend(),
		Consensus::REWARD,
		[](uint64_t reward, const TransactionKernel& kernel) { return reward + kernel.GetFee(); }
	);

	std::unique_ptr<Commitment> pRewardCommitment = Crypto::CommitTransparent(reward);
	if (pRewardCommitment == nullptr)
	{
		return false;
	}

	const std::vector<Commitment> overCommitment({ *pRewardCommitment });
	const std::unique_ptr<Commitment> pOutputAdjustedSum = Crypto::AddCommitments(coinbaseCommitments, overCommitment);

	const std::unique_ptr<Commitment> pKernelSum = Crypto::AddCommitments(coinbaseKernelExcesses, std::vector<Commitment>());

	// Verify the kernel sum equals the output sum accounting for block fees.
	if (pOutputAdjustedSum == nullptr || pKernelSum == nullptr)
	{
		return false;
	}

	return *pKernelSum == *pOutputAdjustedSum;
}